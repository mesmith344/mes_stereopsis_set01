# -*- coding: utf-8 -*-
"""
generate_mes_stereopsis_set01.py

A Python Blender script for generating many paired image files of random polyhedra at random
distances from two different vantage points (left and right), simulating stereopsis
(aka binocular vision). The image pairs are meant to be used to train a computer model to
estimate distances via stereopsis, an ability which is a component of depth perception.

The generated paired image files have names in this format:

    iiiiiX_(RR.RRR).png

where
    iiiii  = a five digit index number with leading zeroes (00000, 00001, 00002, etc.)
    X      = either the letter L or R, meaning "left" or "right", indicating that the
             image was taken from the left or right vantage point.
    RR.RRR = a floating point number R, with 5 significant digits and a decimal point,
             indicating the approximate distance between the center of the two vantage
             points and the nearest surface of the polyhedron. This number is a dimensionless
             ratio of that distance and the distance between the two vantage points.
             Thus, R is given by:
             
                 R = Ds / Dv
                 
                 where
                     Ds is the approximate distance to the nearest surface of the polyhedron
                     Dv is the distance between the vantage points
                     
             NOTE: R need not always have two digits to the left of the decimal point and three
			 to the right of it. It could be in the form R.RRRR, RR.RRR, RRR.RR, etc.
			 
A few examples of typical paired image file names are:
    00007L_(15.947).png
    00007R_(15.947).png
    00135L_(2.3118).png
    00135R_(2.3118).png

If the distance between the vantage points Dv were known, as it would be in a robot with two
camera eyes, then Ds could be derived from R and Dv.

The reason the Ds distance is approximate is because the polyhedra have various random shapes,
and are not perfect spheres, (although many are close to being spheres) but this script simplifies
calculating Ds by treating all of the polyhedra as spheres.

The polyhedra are varied in shape, color, size, light source direction, and light intensity, so that
the computer model learns that those are not relevant to stereopsis. Varying the size is especially
important; if the polyhedra size was constant, the model could use the apparent size to estimate
distance, instead of learning stereopsis.

The background color is also varied so that the model doesn't inadvertantly learn that backgrounds
are always a certain color.

A small fraction of images generated by this script will not be usable. I attempted to minimize this
problem, but THE IMAGES WILL NEED TO BE INSPECTED to remove the unusable ones. I apologize for this,
as inspecting thousands of images is tedious work. If an unusable image is found, this script can be
used to generate a new image pair to replace it, so that the number of image pairs remain the same.

A good way to visually inspect many of these images quickly is to use image thumbnails.
A thumbnail image is enough to determine whether the image is USABLE, but not enough to determine
that it is UNUSABLE. To determine if an image is UNUSABLE, you need to look more closely. For example,
a thumbnail may look like a featurelsss black image even when the image actually contains shading
that makes it usable. So I recommend never removing an image as unusable based only on a thumbnail.
If you do so, you may be systematically removing interesting and important edge cases that the model
could benefit from.

Examples of situations resulting in unusable images:

    * The polyhedron's location is not in sight of one or both cameras, resulting in
      featureless images. I have attempted to eliminate this possibility in the script,
      but it may still happen.
      
    * The polyhedron is positioned between the lamp and the camera, blocking all
      light from reaching the camera. This results in featureless black images.
      
    * The pair of images do not share any portion of the polyhedron surface
      between them, which can happen if the polyhedron is very close to the cameras.
      Determining if this is the case may sometimes be difficult. If this happens,
      the computer model won't be able to determine the amount of image shift between
      left and right images, and thus won't be able to use stereopsis.
      
Fewer unusable images would be generated if this script were modified so that the polyhedra were
always far enough from the cameras, but this would prevent the model from learning how to do stereopsis
on near objects.

---- MES, August 2018
"""

import bmesh
import bpy
import errno
import math
import mathutils
import os
import random

#### CONSTANTS ####
# Dv: distance between cameras (in Blender grid units)
# Since the polyhedron sizes and distances are being varied, there is no need to also vary Dv.
Dv = 2.0
HALF_Dv = 1.0

# Factors of pi
HALF_PI = math.pi / 2.0
TWO_PI = math.pi * 2

# image target folder
IMAGE_TARGET_FOLDER = 'C:/mes/generated_image_sets/mes_stereopsis_set01'

# MAXIMUM Y COORDINATE FOR POLYHEDRON
# (Note: if this is too large, you get more unusable images.)
MAX_Y = 100

# range of image pairs indexes to generate
FIRST_INDEX_NUMBER_TO_GENERATE = 0
LAST_INDEX_NUMBER_TO_GENERATE = 9

#### END OF CONSTANTS ####

def remove_everything_from_scene():
    for scene in bpy.data.scenes:
        for obj in scene.objects:
            scene.objects.unlink(obj)
    for bpy_data_iter in (
            bpy.data.objects,
            bpy.data.meshes,
            bpy.data.lamps,
            bpy.data.cameras,
            ):
        for id_data in bpy_data_iter:
            bpy_data_iter.remove(id_data)

def add_camera(name, x_coordinate):
    scene = bpy.context.scene
    camera_data = bpy.data.cameras.new(name=name)
    camera_object = bpy.data.objects.new(name=name, object_data=camera_data)
    scene.objects.link(camera_object)
    camera_object.location = (x_coordinate, 0.0, 0.0)
    
    # point camera in positive y-direction
    camera_object.rotation_euler = mathutils.Euler((HALF_PI, 0, 0), 'XYZ')
    
    return camera_object

def get_random_size():
    return random.uniform(0.5, 10.0)

def get_random_polyhedron_location(polyhedron_size):
    # Try to choose an polyhedron location in the view
    # of both cameras and close enough for the cameras to see.
    
    # The polyhedron must be in front of the cameras,
    # which are on the x-axis at y=0 looking in the positive y direction.
    # Use polyhedron_size to prevent the polyhedron from engulfing a camera.
    # The polyhedron_size is the 'radius', not the 'diameter'.
    locY = random.uniform(polyhedron_size + 1.5, MAX_Y)

    # Confine the X and Z coordinates
    # so the polyhedron will be in the field of view of the cameras.
    # The field of view of the cameras is rectangular,
    # wider along the X axis then along the Z axis.
    # These factors were found by experiment, not first principles:
    maxX = locY/6.0
    maxZ = locY/12.0
    
    locX = random.uniform(-maxX, maxX)
    locZ = random.uniform(-maxZ, maxZ)    

    return (locX, locY, locZ)

def get_random_tuples_of_signs():
    signX = 1
    signY = 1
    signZ = 1
    if random.randint(1,2) == 2:
        signX = -1
    if random.randint(1,2) == 2:
        signY = -1
    if random.randint(1,2) == 2:
        signZ = -1
    return (signX, signY, signZ)

def distance(x,y):
    return math.sqrt((y[0]-x[0])**2 + (y[1]-x[1])**2 + (y[2]-x[2])**2)

def distanceToOrigin(x):
    return math.sqrt((x[0])**2 + (x[1])**2 + (x[2])**2)

def get_random_lamp_location(polyhedron_location, polyhedron_size):
    # I found the distribution of the chosen lamp locations
    # to be important to the quality of the overall dataset.
    # If the lamp is placed completely randomly, the portion
    # of the images in which the polyhedron is dark is too great ( >70% ? )
    # (Robots sometimes work in well-lit areas, too.) So I settled on this algorithm
    # which more often lights the polyhedron well.

    if random.randint(1,10) <= 7:
        # 70% of the time do this
        # Bias the lamp position to be well-placed.
        half_distance_to_center = distanceToOrigin(polyhedron_location) / 2.0
        midpoint = tuple(loc/2 for loc in polyhedron_location)
        done = False
        count = 0
        while not done:
            signs = get_random_tuples_of_signs()
            locX = midpoint[0] + (signs[0] * random.uniform(0.0, half_distance_to_center))
            locY = midpoint[1] + (signs[1] * random.uniform(0.0, half_distance_to_center))
            locZ = midpoint[2] + (signs[2] * random.uniform(0.0, half_distance_to_center))
            result = (locX, locY, locZ)
            # did we land inside the polyhedron?
            distance_to_polyhedron = distance(polyhedron_location, result)
            if distance_to_polyhedron > polyhedron_size:
                # the lamp is outside of the polyhedron.
                done = True
            else:
                # the lamp is inside the polyhedron
                count += 1;
                if count>20:
                    # this has never been observed to happen
                    raise Exception('get_random_lamp_location while loop has looped too many times')
    else:
        # 30% of the time do this
        # This algorithm does not bias the lamp position to be well-placed,
        # but we do want some pictures like that.
        signs = get_random_tuples_of_signs()
        locX = polyhedron_location[0] + (signs[0] * random.uniform(polyhedron_size + 2.0, polyhedron_size + 5.0))
        locY = polyhedron_location[1] + (signs[1] * random.uniform(polyhedron_size + 2.0, polyhedron_size + 5.0))
        locZ = polyhedron_location[2] + (signs[2] * random.uniform(polyhedron_size + 2.0, polyhedron_size + 5.0))
        result = (locX, locY, locZ)

    return result
    
def add_lamp(polyhedron_location, polyhedron_size):
    scene = bpy.context.scene
    lamp_data = bpy.data.lamps.new(name="Lamp", type='POINT')
    lamp_object = bpy.data.objects.new(name="Lamp", object_data=lamp_data)
    scene.objects.link(lamp_object)    
    lamp_object.location = get_random_lamp_location(polyhedron_location, polyhedron_size)
    return lamp_object

def get_random_rotation():
    rot1 = random.uniform(-TWO_PI, TWO_PI)
    rot2 = random.uniform(-TWO_PI, TWO_PI)
    rot3 = random.uniform(-TWO_PI, TWO_PI)
    return (rot1, rot2, rot3)

def get_random_color():
    r = random.uniform(0.0, 1.0)
    g = random.uniform(0.0, 1.0)
    b = random.uniform(0.0, 1.0)
    return (r, g, b)

def get_random_background_color():
    # The polyhedra must be lit by the lamp, and are usualy darker because of it.
    # The background color is just magically there in all directions.
    # As a result, the polyhedron will almost always be darker than the background
    # unless we bias the background colors towards being darker as well.
    # (We don't want the model to learn to pay attention to darker objects.)
    if random.randint(1,16) == 16:
        r = random.uniform(0.0, 1.0)
        g = random.uniform(0.0, 1.0)
        b = random.uniform(0.0, 1.0)
    elif random.randint(1,8) == 8:
        r = random.uniform(0.0, 0.5)
        g = random.uniform(0.0, 0.5)
        b = random.uniform(0.0, 0.5)
    elif random.randint(1,4) == 4:
        r = random.uniform(0.0, 0.25)
        g = random.uniform(0.0, 0.25)
        b = random.uniform(0.0, 0.25)
    else:
        r = random.uniform(0.0, 0.125)
        g = random.uniform(0.0, 0.125)
        b = random.uniform(0.0, 0.125)
    return (r, g, b)
	
def add_cube(polyhedron_location, polyhedron_size):
    rotation = get_random_rotation()
    
    # For icospheres, the radius is called "size". For cubes, the size is called "radius". **shrugs**
    bpy.ops.mesh.primitive_cube_add(location=polyhedron_location, rotation=rotation, radius=polyhedron_size)
    
    # get a handle on the cube which was just created
    cube = bpy.data.objects['Cube']

    mat = bpy.data.materials.new(name="MaterialName")
    cube.data.materials.append(mat)
    bpy.context.object.active_material.diffuse_color = get_random_color()

def add_icosphere(polyhedron_location, polyhedron_size):
    rotation = get_random_rotation()
    subdivisions = random.uniform(1.0, 6.0)
    
    bpy.ops.mesh.primitive_ico_sphere_add(subdivisions=subdivisions, size=polyhedron_size, location=polyhedron_location, rotation=rotation)
    
    # get a handle on the sphere which was just created
    sphere = bpy.data.objects['Icosphere']

    mat = bpy.data.materials.new(name="MaterialName")
    sphere.data.materials.append(mat)
    bpy.context.object.active_material.diffuse_color = get_random_color()

def add_polyhedron(polyhedron_location, polyhedron_size):
    if random.randint(1,5) == 5:
        # use a cube a fifth of the time for more shape variety
        add_cube(polyhedron_location, polyhedron_size)
    else:
        add_icosphere(polyhedron_location, polyhedron_size)

def getImageSubfolderName(index):
    subfolder = None
    if index<1000:
        subfolder = '00000-00999'
    elif index>999 and index<2000:
        subfolder = '01000-01999'
    elif index>1999 and index<3000:
        subfolder = '02000-02999'
    elif index>2999 and index<4000:
        subfolder = '03000-03999'
    elif index>3999 and index<5000:
        subfolder = '04000-04999'
    elif index>4999 and index<6000:
        subfolder = '05000-05999'
    elif index>5999 and index<7000:
        subfolder = '06000-06999'
    elif index>6999 and index<8000:
        subfolder = '07000-07999'
    elif index>7999 and index<9000:
        subfolder = '08000-08999'
    elif index>8999 and index<10000:
        subfolder = '09000-09999'
    elif index>9999 and index<11000:
        subfolder = '10000-10999'
    elif index>10999 and index<12000:
        subfolder = '11000-11999'
    elif index>11999 and index<13000:
        subfolder = '12000-12999'
    elif index>12999 and index<14000:
        subfolder = '13000-13999'
    elif index>13999 and index<15000:
        subfolder = '14000-14999'
    elif index>14999 and index<16000:
        subfolder = '15000-15999'
    elif index>15999 and index<17000:
        subfolder = '16000-16999'
    elif index>16999 and index<18000:
        subfolder = '17000-17999'
    elif index>17999 and index<19000:
        subfolder = '18000-18999'
    elif index>18999 and index<20000:
        subfolder = '19000-19999'
    elif index>19999 and index<21000:
        subfolder = '20000-20999'
        
    return subfolder

def makeFoldersIfNecessary(filepath):
    if not os.path.exists(os.path.dirname(filepath)):
        try:
            os.makedirs(os.path.dirname(filepath))
        except OSError as exc: # Guard against race condition
            if exc.errno != errno.EEXIST:
                raise

def generateFilePath(index, lr, R):
    # iiiiiX_(RR.RRR).png
    index_string = str(index).zfill(5)
    subfolder = getImageSubfolderName(index)
    return IMAGE_TARGET_FOLDER + '/' + subfolder + '/' + index_string + lr + '_(' + R + ').jpg'

def render_from_camera(cam, index, lr, R):
    filepath = generateFilePath(index, lr, R)
    makeFoldersIfNecessary(filepath)
    bpy.context.scene.camera = cam
    bpy.data.scenes['Scene'].render.filepath = filepath
    bpy.ops.render.render( write_still=True )
    
#########################################################

print()
print('generate_mes_stereopsis_set01.py is running.')

for index in range(FIRST_INDEX_NUMBER_TO_GENERATE, (LAST_INDEX_NUMBER_TO_GENERATE+1)):
    print('Generating image pair ' + str(index) + '.')
    
    remove_everything_from_scene()
    
    # It did occur to me that I should be able to just add the cameras
    # once before the loop and leave them in place. However, I am still having
    # technical problems with that approach, so this way is 'good enough'.
    camera_r = add_camera('Camera R', HALF_Dv)
    camera_l = add_camera('Camera L', -HALF_Dv)

    # this is like the 'radius' of the polyhedron (not the 'diameter')
    polyhedron_size = get_random_size()
    
    polyhedron_location = get_random_polyhedron_location(polyhedron_size)
    
    # the cameras are centered on the origin
    # Dc = distance from the origin to the center of the polyhedron
    Dc = distanceToOrigin(polyhedron_location)
    
    # Ds = approximate distance from the origin to the nearest surface of the polyhedron
    # (Approximating the polyhedron as a sphere)
    Ds = Dc - polyhedron_size
    
    # Calculate R_exact, the dimensionless ratio Ds / Dv
    # (The distance to the polyhedron's surface divided by the distance between the cameras)
    R_exact = Ds / Dv
    
    # Round R_exact to 5 significant figures, obtaining R as a string for the image file names
    R = '{0:.5g}'.format(R_exact)
    
    # build the scene...
    
    # change the background color
    bpy.data.worlds['World'].horizon_color = get_random_background_color()
    
    # add a lamp in a random location near enough to the polyhedron
    add_lamp(polyhedron_location, polyhedron_size)
    
    # add the polyhedron
    add_polyhedron(polyhedron_location, polyhedron_size)

    # render images from both cameras
    render_from_camera(camera_r, index, 'R', R)
    render_from_camera(camera_l, index, 'L', R)

